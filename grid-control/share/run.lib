#!/bin/sh
# Author: Fred Stober <stober@ekp.uni-karlsruhe.de>

# Error codes
# 101 - file not found
# 102 - directory not found
# 103 - executable not found
# 104 - variable not found

# 105 - env unpacking failed
# 106 - se copy error

# 120 - lower space limit
# 121 - upper space limit
# 122 - min size failure

# 123 - user intervention requested

# >125 - reserved by POSIX

GC_VERSION="$Revision$"

debug_helper() {
	return
	echo  -n "$$:shell:" 1>&2
	for i in `seq ${#BASH_LINENO[*]} -1 0`; do
		[ -n "${BASH_LINENO[$i]}" ] && echo -n "${BASH_LINENO[$i]} " 1>&2
		[ -n "${BASH_SOURCE[$i]}" ] && echo -n "`basename ${BASH_SOURCE[$i]}`:" 1>&2
		[ -n "${FUNCNAME[$i]}" ] && echo -n "${FUNCNAME[$i]}:" 1>&2
	done
	echo "$LINENO ($1)" 1>&2
}

fail() {
	debug_helper $FUNCNAME $LINENO
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	[ -n "$1" ] && CODE=$1 || CODE=$?
	cleanup
	updatejobinfo $CODE
	exit $CODE
}

abort() {
	debug_helper $FUNCNAME $LINENO
	[ -d "$MY_LANDINGZONE" ] && checkdir "Start directory" "$MY_LANDINGZONE" >> $MY_LANDINGZONE/stderr.txt
	[ -d "$MY_SCRATCH" ] && checkdir "Scratch directory" "$MY_SCRATCH" >> $MY_LANDINGZONE/stderr.txt
	cleanup
	[ -n "$1" ] && updatejobinfo $1
	trap - 0 1 2 3 15
	kill4sure $$
}

kill4sure() {
	debug_helper $FUNCNAME $LINENO
	DEPTH=${2:-0}
	if [ $DEPTH -lt 5 ]; then
		(ps -o pid= --ppid $1 2> /dev/null) | while read XPID; do
			kill4sure $XPID $[$DEPTH + 1] &> /dev/null
		done
	fi
	echo "Killing process $1" 1>&2
	kill -15 $1 &> /dev/null
	sleep 1
	kill -9 $1 &> /dev/null
}

updatejobinfo() {
	debug_helper $FUNCNAME $LINENO
	(
		echo "JOBID=$MY_JOBID"
		echo "EXITCODE=$1"
	) > $MY_LANDINGZONE/jobinfo.txt
}

checkfile() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for file $1 ... "
	if [ ! -f "$1" ]; then
		echo "FAILED"
		echo "`basename $1` missing" 1>&2
		fail 101
	else
		echo "OK"
	fi
}

checkdir() {
	debug_helper $FUNCNAME $LINENO
	echo -e "$1:\n$2"
	[ ! -d "$2" ] && echo "$1 not found" 1>&2 && fail 102
	[ "$2" == "invalid" ] && echo "Directory $1" 1>&2 && fail 102
	getrealdir $2 && echo "$1 content:" && ls -al $2 && df -hP . && echo
}

checkbin() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for binary $1 ... "
	if [ -x "$1" ]; then
		echo "OK"
	elif [ -x "`getcommand $1`" ]; then
		echo "OK (`getcommand $1`)"
	else
		echo "FAILED"
		echo "`basename $1` missing" 1>&2
		fail 103
	fi
}

checkvar() {
	debug_helper $FUNCNAME $LINENO
	echo -n "Checking for variable \$$1 ... "
	if [ -z "${!1}" ]; then
		echo "FAILED"
		echo "$1 not set" 1>&2
		fail 104
	else
		echo "OK (\$$1 = ${!1})"
	fi
}

getrealdir() {
	debug_helper $FUNCNAME $LINENO
	[ -d "$1" ] && cd $1 && pwd -P && cd $OLDPWD && return `true`;
	return `false`
}

getscratch() {
	debug_helper $FUNCNAME $LINENO
	# find scratch directory with highest amount of diskspace
	MY_SCRATCH="invalid"

	getscratch_internal() {
		debug_helper $FUNCNAME $LINENO
		MY_SCRATCH="invalid"
		MY_SCRATCHSIZE=-1
		
		# find scratch directory with highest amount of diskspace
		for DIRVAR in $@;
		do
			echo -n "Scratch directory variable: $1 => \"${!DIRVAR}\": " 1>&2
			if [ -n "${!DIRVAR}" ]; then
				DIR=${!DIRVAR}
				[ ! -d "$DIR" ] && shift && continue
				rm -Rf "$DIR/$$" &> /dev/null
				mkdir -p "$DIR/$$" &> /dev/null
				if [ -d "$DIR/$$" ]; then
					SIZE="`getdiskspace $DIR/$$`" &> /dev/null
					echo "$SIZE mb free" 1>&2
					[ "$SIZE" -gt "$MY_SCRATCHSIZE" ] && MY_SCRATCH="$DIR/$$" && MY_SCRATCHSIZE="$SIZE" &> /dev/null
					rm -rf "$DIR/$$" &> /dev/null
				fi
			else
				echo "FAILED" 1>&2
			fi
			shift
		done
		if [ "$MY_SCRATCHSIZE" -gt 0 ]; then
			echo "Selected as scratch directory: $MY_SCRATCH: $MY_SCRATCHSIZE mb free" 1>&2
			mkdir -p "$MY_SCRATCH" &> /dev/null
			echo $MY_SCRATCH
			return 0;
		fi
		return 1;
	}

	getscratch_internal SCRATCH_DIRECTORY LOCAL_SCRATCH NODE_SCRATCH USER_SCRATCH EDG_WL_SCRATCH OSG_WN_TMP LCG_TMP DG_WL_SCRATCH && return 0
	echo "Site doesn't define scratch directory variables! Trying other locations..." 1>&2
	export

	# FAIL or continue?
	fail 123

	export GC_TMP="/tmp"
	getscratch_internal MY_LANDINGZONE HOME TMPDIR GC_TMP && return 0

	fail 102
}

# Clean up user area
cleanup() {
	debug_helper $FUNCNAME $LINENO
	cd "$MY_LANDINGZONE"
	[ -f "$MY_MARKER" ] && rm -Rf "$MY_MARKER" &> /dev/null
	[ -d "$MY_SCRATCH" ] && rm -Rf "$MY_SCRATCH" &> /dev/null
}

# TODO: choose grid commands
getcommand() {
	debug_helper $FUNCNAME $LINENO
	which $@ 2> /dev/null | head -n 1
}

my_move() {
	debug_helper $FUNCNAME $LINENO
	[ ! -d "$1" ] && fail 102
	[ ! -d "$2" ] && fail 102
	[ -z "$3" ] && return
	for file in `cd $1 && ls $(eval "echo $3") && cd $OLDPWD`; do
		test -f "$1/$file" && mv "$1/$file" "$2/$file"
	done
}

# TODO: Directory operations
se_copy() {
	debug_helper $FUNCNAME $LINENO
	#checkbin "globus-url-copy" || fail 103
	echo "Using storage element!"
	echo "Copy $3 from $1 to $2"
	BADCOUNT=0
	case "$1" in
		"gsiftp://"*)
			# copy from SE to WN
			if [[ "$3" == *\** ]]; then
				# Wildcard used => gridftp-ls
				GRIDFTP_LS="`getcommand glite-gridftp-ls edg-gridftp-ls`"
				checkbin ${GRIDFTP_LS:-"glite-gridftp-ls"} || fail 103
				for pat1 in $3; do
					pat="`echo ${SE_INPUT_PATTERN:-__X__} | var_replacer $pat1`"
					for file in "`$GRIDFTP_LS $1/$pat`"; do
						[ -n "$file" ] && SOURCE_FILES="$SOURCE_FILES `basename $file`"
					done
				done
			else
				SOURCE_FILES="`echo ${SE_INPUT_PATTERN:-__X__} | var_replacer $3`"
			fi
			SOURCE_PATTERN="__X__"
			TARGET_PATTERN="__X__"
			;;
		"file://"*)
			# copy from site to SE
			SOURCE_PATTERN="__X__"
			TARGET_PATTERN="${SE_OUTPUT_PATTERN:-__X__}"
			SOURCE_FILES="`cd ${1#file://} && ls -d $3 && cd $OLDPWD`"
			for file in $SOURCE_FILES; do
				SOURCE_FN="`echo $SOURCE_PATTERN | var_replacer $file`"
				[ "`getdiskusage ${1#file://}/$SOURCE_FN`" -lt "${SE_MINFILESIZE:-0}" ] && fail 122
			done
			;;
		*)	fail 106
			;;
	esac
	echo
	for file in $SOURCE_FILES; do
		SOURCE_FN="`echo $SOURCE_PATTERN | var_replacer $file`"
		TARGET_FN="`echo $TARGET_PATTERN | var_replacer $file`"
		echo "globus-url-copy \"$1/$SOURCE_FN\" \"$2/$TARGET_FN\""
		globus-url-copy "$1/$SOURCE_FN" "$2/$TARGET_FN" || BADCOUNT=$[$BADCOUNT+1]
	done
	[ $BADCOUNT -ne 0 ] && echo "$BADCOUNT errors occurred during SE access" && fail 106
}

var_replacer() {
	debug_helper $FUNCNAME $LINENO
	j=0
	SEED_REPLACER=""
	for i in $SEEDS; do
		SEED_REPLACER="$SEED_REPLACER -e s@__SEED_${j}__@$[i+$MY_JOBID]@"
		j=$[j+1]
	done

	TMP_CSEC=$(echo "`date +%s` * 100 + `date +%N` / 10000000" | bc)
	SEED_ALT=$(echo "$TMP_CSEC % 900000000" | bc)
	sed \
		-e "s@__X__@$1@" \
		-e "s@__FILE_NAMES__@$FILE_NAMES@" \
		-e "s@__MAX_EVENTS__@$MAX_EVENTS@" \
		-e "s@__TIMESTAMP__@`date +%s`@" \
		-e "s@__DATE__@`date +%F`@" \
		-e "s@__SKIP_EVENTS__@$SKIP_EVENTS@" \
		-e "s@__SEED_ALT__@$SEED_ALT@" \
		-e "s@__MY_JOBID__@$MY_JOBID@" \
		-e "s@__MY_JOB__@$MY_JOBID@" \
		$SEED_REPLACER
}

_find() {
	debug_helper $FUNCNAME $LINENO
	if test -f "`pwd`/$1"; then
		echo "`pwd`/$1"
	elif test -f "$MY_SCRATCH/$1"; then
		echo "$MY_SCRATCH/$1"
	elif test -f "$MY_LANDINGZONE/$1"; then
		echo "$MY_LANDINGZONE/$1"
	else
		echo "$1 not found" 2>&1
	fi
}

# Get used space in mb
getdiskusage() {
	debug_helper $FUNCNAME $LINENO
	TMPVAR="`du --block-size=m -s $1 | cut -f 1 | sed -e 's/M//'`"
	echo ${TMPVAR:-100000000}
}

# Get free space in mb
getdiskspace() {
	debug_helper $FUNCNAME $LINENO
	TMPVAR="`df --block-size=m -P $1 | tail -n 1 | awk '{print $4}' | sed -e 's/M//'`"
	echo ${TMPVAR:-0}
}

# Check for disk usage: <env var limit prefix> <dir>
monitordirlimits() {
	debug_helper $FUNCNAME $LINENO
	LIMIT_LL="${1}_LL"
	LIMIT_UL="${1}_UL"
	[ "$1" == "SCRATCH" ] && DEFAULT_LL=100 || DEFAULT_LL=1000
	[ "$1" == "SCRATCH" ] && DEFAULT_UL=50 || DEFAULT_UL=100
	while [ -f "$MY_MARKER" ]; do
		[ -z "$MDL_CFG" -a -f "$MY_SCRATCH/_config.sh" ] && source "$MY_SCRATCH/_config.sh" && MDL_CFG="set"
		DISKSPACE="`getdiskspace $2`"
		if [ $DISKSPACE -lt ${!LIMIT_LL:-$DEFAULT_LL} ]; then
			echo "Lower space limit reached on $2" 1>&2
			updatejobinfo 120
			kill -SIGTERM $$
		fi
		DISKUSAGE="`getdiskusage $2`"
		if [ $DISKUSAGE -gt ${!LIMIT_UL:-$DEFAULT_UL} ]; then
			echo "Upper space limit reached on $2" 1>&2
			updatejobinfo 121
			kill -SIGTERM $$
		fi
		sleep 20;
	done
}
