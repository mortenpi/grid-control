#!/usr/bin/env python

#
# $Id: dls-list,v 1.11 2006/09/21 15:18:55 delgadop Exp $
#
# DLS Client. $Name: DLS_0_1_1 $.
# Antonio Delgado Peris. CIEMAT. CMS.
# 

#########################################
# Imports 
#########################################
import dlsApi
DLS_VERB_HIGH = dlsApi.DLS_VERB_HIGH
DLS_VERB_WARN = dlsApi.DLS_VERB_WARN
from dlsDataObjects import DlsLocation, DlsFileBlock, DlsEntry
import dlsClient
import time
import sys
import getopt
from stat import *


################## GLOBAL CONSTANTS ########################
THIS_YEAR = time.localtime()[0]


######################### FUNCTIONS ########################
def usage():
   """
    Provides usage information
   """
   print "Usage: dls-list [-v, -e, -i, -l, -r, -g] <fileblock>"
   print "       dls-list [-v, -e, -i, -l, -r, -g] -f <listing_file>"
   print "       dls-list -u"
   print "       dls-list -h"


def options():
   """
    Provides some information regarding the available options
   """
   print """Options summary:
   -h, --help
   -u, --usage
   -v, --verbose <verb_level>
   -e, --endpoint <endpoint>
   -i, --interface-type <iface_type>
   -l, --long
   -r, --recursive
   -g, --guid
   -f, --from-file <filename>
   """
def example():
  """
   Provides with an example of correct use of the script
  """
  print """
  """

def help():
   """
    Provides some help information
   """
   print """Prints FileBlocks information of the specified FileBlock
or, for DLS implementations with hierarchical FileBlock namespace, 
of FileBlocks in the specified FileBlock namespace directory.

If "-l" is specified, some FileBlock attributes are printed before the
FileBlock name. Printed attributes may depend on the DLS implementation.
Currently, printed attributes (if supported by the implementation) are:
filemode, number of files in a directory, owner, group owner and last
modification date.

If "-r" is specified, subdirectories contained in the specified
FileBlock directory are listed recursively (for arguments being normal
FileBlocks, this option is ignored).

The use of "-g" will cause, for DLS implementations supporting the concept
of FileBlock unique identifier, the print of this identifier after
every FileBlock listed. Other implementations will just ignore this option.

The "-f" option can be used to retrieve FileBlock names from a file rather
than from the given arguments. The file must contain one line per FileBlock
to be listed.

The "-e" option can be used to set the DLS endpoint to use. If not specified,
the endpoint is retrieved from:
    - DLS_ENDPOINT environmental variable
If the DLS endpoint cannot be retrieved in any of these ways, the command fails.
The endpoint should be of the form: "hname[:port][/path/to/DLS]", where a
default port is used if not specified, and the path to DLS may be required for
some DLS implementations (and ignored otherwise).

The "-i" option specifies the type of interface that should be used (which
depends on the DLS backend to access). If not specified, the interface type
is retrieved from:
    - DLS_TYPE environmental variable
If the interface type cannot be retrieved in any of these ways, the command fails.
Currently accepted values are:
    - DLS_TYPE_LFC  =>  DlsLfcApi class (complete API with LFC back-end)
    - DLS_TYPE_DLI  =>  DlsDliClient class (getLocations only API with LFC back-end)
    - DLS_TYPE_MYSQL =>  DlsMySQLApi  class (complete API with MySQL proto back-end) 

The "-v" option sets the verbosity level for the command. Accepted values are:
  -v 0 ==> print nothing else than error messages
  -v 1 ==> print also warning messages (default)
  -v 2 ==> print extra debug information

If "-u" is specified, usage information is displayed.

If "-h" is specified, help information is displayed.
   """
   options()
   usage()



def showFileBlocks(iface, lineList, longList, recursive, guid, verbose):
   """
   Prints the specified FileBlocks information. lineList is a list
   of string, each holding a FileBlock name.
    
   If longList is True, some attributes are also printed.
   Currently printed attributes are:
   filemode, number of files in a directory, owner, group owner, last
   modification date.
   
   Throws DlsLfcApiError if there is a problem in the DLS operation.
   """
   more = longList or guid
   fbList = []
   for line in lineList:

      # Split
      line = (line.strip()).split()
      if(not line):
         continue

      # Get LFN
      lfn = line.pop(0)

      # Store all the FileBlocks 
      fbList.append(lfn)

   if(verbose >= 2):
      print "--DlsApi.listFileBlocks(",
      for i in fbList: print i, ";",
      print ")"

   # Get the locations (and let the caller deal with the exception...)
   if(len(fbList) == 1):
      # Need this for the directory listing (if in a list is like ls -d)
      resList = iface.listFileBlocks(fbList[0], longList=more, recursive=recursive, session=True)
   else:
      resList = iface.listFileBlocks(fbList, longList=more, recursive=recursive, session=True)

   # Make sure the obtained result is a list
   if(not isinstance(resList, list)):
     resList = [resList]

   # Print the entries
   for fB in resList:
      if(longList):
         values = []
         for i in ["filemode", "nlink", "uid", "gid", "filesize", "mtime"]:
            try:
                values.append(fB.attribs[i])
            except KeyError, inst:
                values.append("UNKNOWN")

         # Interpret the filemode to print it as a string
         if(not (values[0] == "UNKNOWN")):
            modestr = [""] * 10
            if (values[0] & S_IFDIR):
               modestr[0] = 'd'
            else:
               if ((values[0] & S_IFLNK) == S_IFLNK):
                  modestr[0] = 'l';
               else:
                  modestr[0] = '-';
            if (values[0] & S_IRUSR):  modestr[1] = 'r'
            else:                      modestr[1] = '-'
            if (values[0] & S_IWUSR):  modestr[2] = 'w'
            else:                      modestr[2] = '-'
            if (values[0] & S_IXUSR):
               if (values[0] & S_ISUID):
                  modestr[3] = 's'
               else:
                  modestr[3] = 'x'
            else:
               modestr[3] = '-'
            if (values[0] & S_IRGRP):  modestr[4] = 'r'
            else:                      modestr[4] = '-'
            if (values[0] & S_IWGRP):  modestr[5] = 'w'
            else:                      modestr[5] = '-'
            if (values[0] & S_IXGRP):
               if (values[0] & S_ISGID):
                  modestr[6] = 's'
               else:
                  modestr[6] = 'x'
            else:
               modestr[6] = '-'
            if (values[0] & S_IROTH):  modestr[7] = 'r'
            else:                      modestr[7] = '-'
            if (values[0] & S_IWOTH):  modestr[8] = 'w'
            else:                      modestr[8] = '-'
            if (values[0] & S_IXOTH):
               if (values[0] & S_ISVTX):
                  modestr[9] = 't'
               else:
                  modestr[9] = 'x'
            else:
               modestr[9] = '-'

            values[0] = ""
            for char in modestr:
               values[0] += char

         print str(values[0]) + "\t" + str(values[1]),
         print str(values[2]) + "\t" + str(values[3]) + "\t" + str(values[4]) + "\t",

         # Format the time 
         if(not (values[5] == "UNKNOWN")):
            time_tuple = time.localtime(fB.attribs["mtime"])
            if(time_tuple[0] != THIS_YEAR):
               fmt = "%b %d %Y"
            else:
               fmt = "%b %d %H:%M"
            print '\t', time.strftime(fmt, time_tuple), '\t',
         else:
            print '\t', values[5], '\t',
      
      # In any case, print the name 
      print fB.name,

      if(guid):
         print '\t',fB.getGuid(),

      print         



###################### MAIN FUNCTION ########################

def main(pArgs):
   """
    Performes the main task of the script (invoked directly).
    For information on its functionality, please call the help function.
   """

 # Options and args... 
 
   longoptions=["help","usage","long","recursive","endpoint","interface-type","verbose","guid","from-file"]
   try:
      optlist, args = getopt.getopt(pArgs, 'hulre:i:v:gf:', longoptions)
   except getopt.GetoptError, inst:
      sys.stderr.write("Bad usage: "+str(inst)+'\n')
      usage()
      sys.exit(-1)

   err=0
   longList = False
   recursive = False
   admitted_verb_values = [0, 1, 2]
   verbose = 1
   endpoint = None
   iface_type = None
   admitted_iface_types = ["DLS_TYPE_LFC", "DLS_TYPE_DLI", "DLS_TYPE_MYSQL"]
   guid = False
   fromFile = False
   fname=""
   for opt, val in optlist:
       if opt in ("-h", "--help"):
           help()
           return -1

       elif opt in ("-u", "--usage"):
           usage()
           return -1
           
       elif opt in ("-l", "--long"):
           longList = True
           
       elif opt in ("-r", "--recursive"):
           recursive = True
           
       elif opt in ("-g", "--guid"):
           guid = True           
           
       elif opt in ("-e","--endpoint"):
           endpoint = val

       elif opt in ("-i", "--interface-type"):
           if (not (val in admitted_iface_types)):
              sys.stderr.write("Unsupported interface type: " + val + "\n")
              return -1
           if(val == "DLS_TYPE_LFC"):
              iface_type = dlsClient.DLS_TYPE_LFC
           if(val == "DLS_TYPE_DLI"):
              iface_type = dlsClient.DLS_TYPE_DLI
           if(val == "DLS_TYPE_MYSQL"):
              iface_type = dlsClient.DLS_TYPE_MYSQL

       elif opt in ("-v", "--verbose"):
           try: 
             val = int(val)
           except ValueError, inst:
             sys.stderr.write("Unsupported verbosity value: " + val + "\n")
             return -1
           if (not (val in admitted_verb_values)):
              sys.stderr.write("Unsupported verbosity value: " + val + "\n")
              return -1             
           verbose = val

       elif opt in ("-f","--from-file"):
           fromFile = True
           fname = val
           
  
 # Build the arguments 

   # From file
   if(fromFile):
      try:
         file=open(fname, 'r')
      except IOError, inst:
         msg="The file "+fname+" could not be opened: "+str(inst)+"\n"
         sys.stderr.write(msg)
         return -1
      lineList=file.readlines()
      
   # From command line options
   else:
      if(len(args)<1):
         sys.stderr.write("Not enough input arguments\n")
         usage()
         return(-1)

      line=""
      for token in args:
         line += token +" "
      lineList = [line]

 # Create the interface binding
   try:
      iface = dlsClient.getDlsApi(iface_type, endpoint)
      if(verbose == 2):
         iface.setVerbosity(dlsApi.DLS_VERB_HIGH)
      else:
         if(verbose == 0):
            iface.setVerbosity(dlsApi.DLS_VERB_NONE)
         else:
            if(verbose == 1):
               iface.setVerbosity(dlsApi.DLS_VERB_WARN)
   except dlsApi.DlsApiError, inst:
      msg = "Error when binding the DLS interface: " + str(inst)
      sys.stderr.write(msg+"\n")
      return -1

   
 # Do the query
   try:
     showFileBlocks(iface, lineList, longList, recursive, guid, verbose)
   except dlsApi.DlsApiError, inst:         
      if(inst.rc):  err = inst.rc 
      else:           err = -1
      msg = "Error in the DLS query: %s." % str(inst)
      sys.stderr.write(msg+'\n')

 # Finally, return error code
   return err



######################### SCRIPT ###########################

if __name__ == "__main__":
  sys.exit(main(sys.argv[1:]))
